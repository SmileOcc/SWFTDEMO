// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: cryptos.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

#import "Cryptos.pbobjc.h"
#import "Quote.pbobjc.h"
#import "Secu.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"
#pragma clang diagnostic ignored "-Wdollar-in-identifier-extension"

#pragma mark - Objective C Class declarations
// Forward declarations of Objective C classes that we can use as
// static values in struct initializers.
// We don't use [Foo class] because it is not a static value.
GPBObjCClassDeclaration(OBJECT_QUOTECryptosInfo);
GPBObjCClassDeclaration(OBJECT_QUOTECryptosOrderBook);
GPBObjCClassDeclaration(OBJECT_QUOTECryptosOrderBookItem);
GPBObjCClassDeclaration(OBJECT_QUOTECryptosRealtime);
GPBObjCClassDeclaration(OBJECT_QUOTEMarketStatusInfo);
GPBObjCClassDeclaration(OBJECT_SECUFullID);
GPBObjCClassDeclaration(OBJECT_SECUSecurityName);

#pragma mark - OBJECT_QUOTECryptosRoot

@implementation OBJECT_QUOTECryptosRoot

// No extensions in the file and none of the imports (direct or indirect)
// defined extensions, so no need to generate +extensionRegistry.

@end

#pragma mark - OBJECT_QUOTECryptosRoot_FileDescriptor

static GPBFileDescriptor *OBJECT_QUOTECryptosRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@"yx.quote.v2.object.quote"
                                                 objcPrefix:@"OBJECT_QUOTE"
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - OBJECT_QUOTECryptosKline

@implementation OBJECT_QUOTECryptosKline

@dynamic latestTime;
@dynamic open;
@dynamic high;
@dynamic low;
@dynamic close;
@dynamic amount;
@dynamic volume;
@dynamic preClose;
@dynamic netchng;
@dynamic pctchng;

typedef struct OBJECT_QUOTECryptosKline__storage_ {
  uint32_t _has_storage_[1];
  NSString *open;
  NSString *high;
  NSString *low;
  NSString *close;
  NSString *amount;
  NSString *volume;
  NSString *preClose;
  NSString *netchng;
  NSString *pctchng;
  uint64_t latestTime;
} OBJECT_QUOTECryptosKline__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latestTime",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosKline_FieldNumber_LatestTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosKline__storage_, latestTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "open",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosKline_FieldNumber_Open,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosKline__storage_, open),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "high",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosKline_FieldNumber_High,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosKline__storage_, high),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "low",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosKline_FieldNumber_Low,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosKline__storage_, low),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "close",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosKline_FieldNumber_Close,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosKline__storage_, close),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosKline_FieldNumber_Amount,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosKline__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "volume",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosKline_FieldNumber_Volume,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosKline__storage_, volume),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "preClose",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosKline_FieldNumber_PreClose,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosKline__storage_, preClose),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "netchng",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosKline_FieldNumber_Netchng,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosKline__storage_, netchng),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pctchng",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosKline_FieldNumber_Pctchng,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosKline__storage_, pctchng),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OBJECT_QUOTECryptosKline class]
                                     rootClass:[OBJECT_QUOTECryptosRoot class]
                                          file:OBJECT_QUOTECryptosRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OBJECT_QUOTECryptosKline__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\n\000\t\010\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OBJECT_QUOTECryptosInfo

@implementation OBJECT_QUOTECryptosInfo

@dynamic baseAsset;
@dynamic quoteAsset;
@dynamic basePrecision;
@dynamic quotePrecision;
@dynamic name;
@dynamic secuNamesArray, secuNamesArray_Count;
@dynamic type1;
@dynamic type2;
@dynamic type3;
@dynamic iconURL;
@dynamic displayedSymbol;

typedef struct OBJECT_QUOTECryptosInfo__storage_ {
  uint32_t _has_storage_[1];
  int32_t basePrecision;
  int32_t quotePrecision;
  OBJECT_SECUSecuType1 type1;
  OBJECT_SECUSecuType2 type2;
  OBJECT_SECUSecuType3 type3;
  NSString *baseAsset;
  NSString *quoteAsset;
  NSString *name;
  NSMutableArray *secuNamesArray;
  NSString *iconURL;
  NSString *displayedSymbol;
} OBJECT_QUOTECryptosInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "baseAsset",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosInfo_FieldNumber_BaseAsset,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosInfo__storage_, baseAsset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "quoteAsset",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosInfo_FieldNumber_QuoteAsset,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosInfo__storage_, quoteAsset),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "basePrecision",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosInfo_FieldNumber_BasePrecision,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosInfo__storage_, basePrecision),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "quotePrecision",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosInfo_FieldNumber_QuotePrecision,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosInfo__storage_, quotePrecision),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "name",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosInfo_FieldNumber_Name,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosInfo__storage_, name),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "type1",
        .dataTypeSpecific.enumDescFunc = OBJECT_SECUSecuType1_EnumDescriptor,
        .number = OBJECT_QUOTECryptosInfo_FieldNumber_Type1,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosInfo__storage_, type1),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "type2",
        .dataTypeSpecific.enumDescFunc = OBJECT_SECUSecuType2_EnumDescriptor,
        .number = OBJECT_QUOTECryptosInfo_FieldNumber_Type2,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosInfo__storage_, type2),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "type3",
        .dataTypeSpecific.enumDescFunc = OBJECT_SECUSecuType3_EnumDescriptor,
        .number = OBJECT_QUOTECryptosInfo_FieldNumber_Type3,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosInfo__storage_, type3),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "secuNamesArray",
        .dataTypeSpecific.clazz = GPBObjCClass(OBJECT_SECUSecurityName),
        .number = OBJECT_QUOTECryptosInfo_FieldNumber_SecuNamesArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosInfo__storage_, secuNamesArray),
        .flags = (GPBFieldFlags)(GPBFieldRepeated | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "iconURL",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosInfo_FieldNumber_IconURL,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosInfo__storage_, iconURL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "displayedSymbol",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosInfo_FieldNumber_DisplayedSymbol,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosInfo__storage_, displayedSymbol),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OBJECT_QUOTECryptosInfo class]
                                     rootClass:[OBJECT_QUOTECryptosRoot class]
                                          file:OBJECT_QUOTECryptosRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OBJECT_QUOTECryptosInfo__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\007\001\t\000\002\n\000\003\r\000\004\016\000\t\000secuNames\000\n\005!!\000\013\017\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t OBJECT_QUOTECryptosInfo_Type1_RawValue(OBJECT_QUOTECryptosInfo *message) {
  GPBDescriptor *descriptor = [OBJECT_QUOTECryptosInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OBJECT_QUOTECryptosInfo_FieldNumber_Type1];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOBJECT_QUOTECryptosInfo_Type1_RawValue(OBJECT_QUOTECryptosInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [OBJECT_QUOTECryptosInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OBJECT_QUOTECryptosInfo_FieldNumber_Type1];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t OBJECT_QUOTECryptosInfo_Type2_RawValue(OBJECT_QUOTECryptosInfo *message) {
  GPBDescriptor *descriptor = [OBJECT_QUOTECryptosInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OBJECT_QUOTECryptosInfo_FieldNumber_Type2];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOBJECT_QUOTECryptosInfo_Type2_RawValue(OBJECT_QUOTECryptosInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [OBJECT_QUOTECryptosInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OBJECT_QUOTECryptosInfo_FieldNumber_Type2];
  GPBSetMessageRawEnumField(message, field, value);
}

int32_t OBJECT_QUOTECryptosInfo_Type3_RawValue(OBJECT_QUOTECryptosInfo *message) {
  GPBDescriptor *descriptor = [OBJECT_QUOTECryptosInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OBJECT_QUOTECryptosInfo_FieldNumber_Type3];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOBJECT_QUOTECryptosInfo_Type3_RawValue(OBJECT_QUOTECryptosInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [OBJECT_QUOTECryptosInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OBJECT_QUOTECryptosInfo_FieldNumber_Type3];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - OBJECT_QUOTECryptosQuote

@implementation OBJECT_QUOTECryptosQuote

@dynamic hasId_p, id_p;
@dynamic hasMsInfo, msInfo;
@dynamic hasInfo, info;
@dynamic hasRealtime, realtime;
@dynamic hasOrderBook, orderBook;

typedef struct OBJECT_QUOTECryptosQuote__storage_ {
  uint32_t _has_storage_[1];
  OBJECT_SECUFullID *id_p;
  OBJECT_QUOTECryptosRealtime *realtime;
  OBJECT_QUOTECryptosOrderBook *orderBook;
  OBJECT_QUOTEMarketStatusInfo *msInfo;
  OBJECT_QUOTECryptosInfo *info;
} OBJECT_QUOTECryptosQuote__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = GPBObjCClass(OBJECT_SECUFullID),
        .number = OBJECT_QUOTECryptosQuote_FieldNumber_Id_p,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosQuote__storage_, id_p),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "realtime",
        .dataTypeSpecific.clazz = GPBObjCClass(OBJECT_QUOTECryptosRealtime),
        .number = OBJECT_QUOTECryptosQuote_FieldNumber_Realtime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosQuote__storage_, realtime),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "orderBook",
        .dataTypeSpecific.clazz = GPBObjCClass(OBJECT_QUOTECryptosOrderBook),
        .number = OBJECT_QUOTECryptosQuote_FieldNumber_OrderBook,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosQuote__storage_, orderBook),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "msInfo",
        .dataTypeSpecific.clazz = GPBObjCClass(OBJECT_QUOTEMarketStatusInfo),
        .number = OBJECT_QUOTECryptosQuote_FieldNumber_MsInfo,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosQuote__storage_, msInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "info",
        .dataTypeSpecific.clazz = GPBObjCClass(OBJECT_QUOTECryptosInfo),
        .number = OBJECT_QUOTECryptosQuote_FieldNumber_Info,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosQuote__storage_, info),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OBJECT_QUOTECryptosQuote class]
                                     rootClass:[OBJECT_QUOTECryptosRoot class]
                                          file:OBJECT_QUOTECryptosRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OBJECT_QUOTECryptosQuote__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\004\t\000\016\006\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OBJECT_QUOTECryptosRealtime

@implementation OBJECT_QUOTECryptosRealtime

@dynamic latestTime;
@dynamic high;
@dynamic low;
@dynamic now;
@dynamic preClose;
@dynamic open;
@dynamic avg;
@dynamic netchng;
@dynamic pctchng;
@dynamic amount;
@dynamic volume;
@dynamic high52W;
@dynamic low52W;
@dynamic trdStatus;

typedef struct OBJECT_QUOTECryptosRealtime__storage_ {
  uint32_t _has_storage_[1];
  OBJECT_QUOTETradingStatus trdStatus;
  NSString *high;
  NSString *low;
  NSString *now;
  NSString *preClose;
  NSString *open;
  NSString *avg;
  NSString *netchng;
  NSString *pctchng;
  NSString *amount;
  NSString *volume;
  NSString *high52W;
  NSString *low52W;
  uint64_t latestTime;
} OBJECT_QUOTECryptosRealtime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latestTime",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_LatestTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, latestTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "high",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_High,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, high),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "low",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_Low,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, low),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "now",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_Now,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, now),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "preClose",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_PreClose,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, preClose),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "open",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_Open,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, open),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avg",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_Avg,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, avg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "netchng",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_Netchng,
        .hasIndex = 7,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, netchng),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pctchng",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_Pctchng,
        .hasIndex = 8,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, pctchng),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_Amount,
        .hasIndex = 9,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "volume",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_Volume,
        .hasIndex = 10,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, volume),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "high52W",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_High52W,
        .hasIndex = 11,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, high52W),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "low52W",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_Low52W,
        .hasIndex = 12,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, low52W),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "trdStatus",
        .dataTypeSpecific.enumDescFunc = OBJECT_QUOTETradingStatus_EnumDescriptor,
        .number = OBJECT_QUOTECryptosRealtime_FieldNumber_TrdStatus,
        .hasIndex = 13,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosRealtime__storage_, trdStatus),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldHasEnumDescriptor | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeEnum,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OBJECT_QUOTECryptosRealtime class]
                                     rootClass:[OBJECT_QUOTECryptosRoot class]
                                          file:OBJECT_QUOTECryptosRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OBJECT_QUOTECryptosRealtime__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\005\001\n\000\005\010\000\014\007\000\r\006\000\017\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t OBJECT_QUOTECryptosRealtime_TrdStatus_RawValue(OBJECT_QUOTECryptosRealtime *message) {
  GPBDescriptor *descriptor = [OBJECT_QUOTECryptosRealtime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OBJECT_QUOTECryptosRealtime_FieldNumber_TrdStatus];
  return GPBGetMessageRawEnumField(message, field);
}

void SetOBJECT_QUOTECryptosRealtime_TrdStatus_RawValue(OBJECT_QUOTECryptosRealtime *message, int32_t value) {
  GPBDescriptor *descriptor = [OBJECT_QUOTECryptosRealtime descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:OBJECT_QUOTECryptosRealtime_FieldNumber_TrdStatus];
  GPBSetMessageRawEnumField(message, field, value);
}

#pragma mark - OBJECT_QUOTECryptosTick

@implementation OBJECT_QUOTECryptosTick

@dynamic latestTime;
@dynamic price;
@dynamic volume;
@dynamic direction;
@dynamic id_p;

typedef struct OBJECT_QUOTECryptosTick__storage_ {
  uint32_t _has_storage_[1];
  int32_t direction;
  NSString *price;
  NSString *volume;
  uint64_t latestTime;
  int64_t id_p;
} OBJECT_QUOTECryptosTick__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latestTime",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosTick_FieldNumber_LatestTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosTick__storage_, latestTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "price",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosTick_FieldNumber_Price,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosTick__storage_, price),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "volume",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosTick_FieldNumber_Volume,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosTick__storage_, volume),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "direction",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosTick_FieldNumber_Direction,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosTick__storage_, direction),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "id_p",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosTick_FieldNumber_Id_p,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosTick__storage_, id_p),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OBJECT_QUOTECryptosTick class]
                                     rootClass:[OBJECT_QUOTECryptosRoot class]
                                          file:OBJECT_QUOTECryptosRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OBJECT_QUOTECryptosTick__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OBJECT_QUOTECryptosOrderBook

@implementation OBJECT_QUOTECryptosOrderBook

@dynamic itemsArray, itemsArray_Count;
@dynamic latestTime;

typedef struct OBJECT_QUOTECryptosOrderBook__storage_ {
  uint32_t _has_storage_[1];
  NSMutableArray *itemsArray;
  uint64_t latestTime;
} OBJECT_QUOTECryptosOrderBook__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "itemsArray",
        .dataTypeSpecific.clazz = GPBObjCClass(OBJECT_QUOTECryptosOrderBookItem),
        .number = OBJECT_QUOTECryptosOrderBook_FieldNumber_ItemsArray,
        .hasIndex = GPBNoHasBit,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosOrderBook__storage_, itemsArray),
        .flags = GPBFieldRepeated,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "latestTime",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosOrderBook_FieldNumber_LatestTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosOrderBook__storage_, latestTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OBJECT_QUOTECryptosOrderBook class]
                                     rootClass:[OBJECT_QUOTECryptosRoot class]
                                          file:OBJECT_QUOTECryptosRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OBJECT_QUOTECryptosOrderBook__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\002\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OBJECT_QUOTECryptosOrderBookItem

@implementation OBJECT_QUOTECryptosOrderBookItem

@dynamic bidPrice;
@dynamic bidVolume;
@dynamic askPrice;
@dynamic askVolume;

typedef struct OBJECT_QUOTECryptosOrderBookItem__storage_ {
  uint32_t _has_storage_[1];
  NSString *bidPrice;
  NSString *bidVolume;
  NSString *askPrice;
  NSString *askVolume;
} OBJECT_QUOTECryptosOrderBookItem__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "bidPrice",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosOrderBookItem_FieldNumber_BidPrice,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosOrderBookItem__storage_, bidPrice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "bidVolume",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosOrderBookItem_FieldNumber_BidVolume,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosOrderBookItem__storage_, bidVolume),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "askPrice",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosOrderBookItem_FieldNumber_AskPrice,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosOrderBookItem__storage_, askPrice),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "askVolume",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosOrderBookItem_FieldNumber_AskVolume,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosOrderBookItem__storage_, askVolume),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OBJECT_QUOTECryptosOrderBookItem class]
                                     rootClass:[OBJECT_QUOTECryptosRoot class]
                                          file:OBJECT_QUOTECryptosRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OBJECT_QUOTECryptosOrderBookItem__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\004\002\010\000\003\t\000\004\010\000\005\t\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - OBJECT_QUOTECryptosTimeline

@implementation OBJECT_QUOTECryptosTimeline

@dynamic latestTime;
@dynamic price;
@dynamic avg;
@dynamic volume;
@dynamic amount;
@dynamic netchng;
@dynamic pctchng;

typedef struct OBJECT_QUOTECryptosTimeline__storage_ {
  uint32_t _has_storage_[1];
  NSString *price;
  NSString *avg;
  NSString *volume;
  NSString *amount;
  NSString *netchng;
  NSString *pctchng;
  uint64_t latestTime;
} OBJECT_QUOTECryptosTimeline__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "latestTime",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosTimeline_FieldNumber_LatestTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosTimeline__storage_, latestTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeUInt64,
      },
      {
        .name = "price",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosTimeline_FieldNumber_Price,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosTimeline__storage_, price),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "avg",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosTimeline_FieldNumber_Avg,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosTimeline__storage_, avg),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "volume",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosTimeline_FieldNumber_Volume,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosTimeline__storage_, volume),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "amount",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosTimeline_FieldNumber_Amount,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosTimeline__storage_, amount),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "netchng",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosTimeline_FieldNumber_Netchng,
        .hasIndex = 5,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosTimeline__storage_, netchng),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "pctchng",
        .dataTypeSpecific.clazz = Nil,
        .number = OBJECT_QUOTECryptosTimeline_FieldNumber_Pctchng,
        .hasIndex = 6,
        .offset = (uint32_t)offsetof(OBJECT_QUOTECryptosTimeline__storage_, pctchng),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldClearHasIvarOnZero),
        .dataType = GPBDataTypeString,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[OBJECT_QUOTECryptosTimeline class]
                                     rootClass:[OBJECT_QUOTECryptosRoot class]
                                          file:OBJECT_QUOTECryptosRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(OBJECT_QUOTECryptosTimeline__storage_)
                                         flags:(GPBDescriptorInitializationFlags)(GPBDescriptorInitializationFlag_UsesClassRefs | GPBDescriptorInitializationFlag_Proto3OptionalKnown)];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    #if defined(DEBUG) && DEBUG
      NSAssert(descriptor == nil, @"Startup recursed!");
    #endif  // DEBUG
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
